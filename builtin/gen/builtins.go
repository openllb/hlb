//go:generate go run ../../cmd/builtingen ../../language/builtin.hlb ../lookup.go

package gen

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"html/template"
	"io"
	"log"
	"os"
	"strconv"
	"strings"

	"github.com/openllb/hlb/parser"
	"github.com/openllb/hlb/parser/ast"
	"github.com/openllb/hlb/pkg/filebuffer"
)

type BuiltinData struct {
	Command     string
	FuncsByKind map[ast.Kind][]ParsedFunc
	Reference   string
}

type ParsedFunc struct {
	Name    string
	Params  []*ast.Field
	Effects []*ast.Field
}

func GenerateBuiltins(ctx context.Context, r io.Reader) ([]byte, error) {
	files := filebuffer.NewBuffers()
	ctx = filebuffer.WithBuffers(ctx, files)
	mod, err := parser.Parse(ctx, r)
	if err != nil {
		return nil, err
	}

	funcsByKind := make(map[ast.Kind][]ParsedFunc)
	for _, decl := range mod.Decls {
		fun := decl.Func
		if fun == nil {
			continue
		}

		var effects []*ast.Field
		if fun.Effects != nil && fun.Effects.Effects != nil {
			effects = fun.Effects.Effects.Fields()
		}

		kind := fun.Type.Kind
		funcsByKind[kind] = append(funcsByKind[kind], ParsedFunc{
			Name:    fun.Name.Text,
			Params:  fun.Params.Fields(),
			Effects: effects,
		})
	}

	fb := files.Get(mod.Pos.Filename)
	data := BuiltinData{
		Command:     fmt.Sprintf("builtingen %s", strings.Join(os.Args[1:], " ")),
		FuncsByKind: funcsByKind,
		Reference:   fmt.Sprintf("`%s`", string(fb.Bytes())),
	}

	var buf bytes.Buffer
	err = referenceTmpl.Execute(&buf, &data)
	if err != nil {
		return nil, err
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = buf.Bytes()
	}

	return src, nil
}

var tmplFunctions = template.FuncMap{
	"kind": func(kind ast.Kind) template.HTML {
		switch kind {
		case ast.String:
			return template.HTML("ast.String")
		case ast.Int:
			return template.HTML("ast.Int")
		case ast.Bool:
			return template.HTML("ast.Bool")
		case ast.Filesystem:
			return template.HTML("ast.Filesystem")
		default:
			return template.HTML(strconv.Quote(string(kind)))
		}
	},
}

var referenceTmpl = template.Must(template.New("reference").Funcs(tmplFunctions).Parse(`
// Code generated by {{.Command}}; DO NOT EDIT.

package builtin

import "github.com/openllb/hlb/parser/ast"

type BuiltinLookup struct {
	ByKind map[ast.Kind]LookupByKind
}

type LookupByKind struct {
	 Func map[string]FuncLookup
}

type FuncLookup struct {
	Params []*ast.Field
	Effects []*ast.Field
}

var (
	Lookup = BuiltinLookup{
		ByKind: map[ast.Kind]LookupByKind{
			{{range $kind, $funcs := .FuncsByKind}}{{kind $kind}}: {
				Func: map[string]FuncLookup{
					{{range $i, $func := $funcs}}"{{$func.Name}}": {
						Params:  []*ast.Field{
							{{range $i, $param := $func.Params}}ast.NewField({{kind $param.Type.Kind}}, "{{$param.Name}}", {{if $param.Modifier}}true{{else}}false{{end}}),
							{{end}}
						},
						Effects: []*ast.Field{
							{{range $i, $effect := $func.Effects}}ast.NewField({{kind $effect.Type.Kind}}, "{{$effect.Name}}", false),
							{{end}}
						},
					},
					{{end}}
				},
			},
			{{end}}
		},
	}

	Reference = {{.Reference}}
)
`))
